<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>树形结构可视化（中心0,0，间距75）</title>
    <style>
        canvas { border: 1px solid #eee; background: #fafafa; }
        .tooltip { position: fixed; padding: 4px 8px; background: rgba(0,0,0,0.8); color: #fff; font-size: 12px; border-radius: 4px; pointer-events: none; display: none; }
    </style>
</head>
<body>
    <canvas id="treeCanvas" width="1200" height="800"></canvas>
    <div class="tooltip" id="tooltip"></div>

    <script>
        // 1. 核心算法：计算节点角度与坐标（中心0,0，最小间距75）
        function calcNodePosWithMinSpacing(node, parentNode = null, level = 1, minSpacing = 75) {
            // 根节点处理：固定x=0,y=0
            if (!parentNode) {
                node._x_ = 0;
                node._y_ = 0;
                node._a_ = null;
                node._p_ = null;

                // 处理teams子节点
                const teams = node.teams !== null ? node.teams : [];
                const teamCount = teams.length;
                teams.forEach((team, idx) => {
                    const radius = minSpacing * level;
                    team._a_ = (2 * Math.PI / teamCount) * idx;
                    // 画布偏移：将中心0,0映射到画布中心（600,400），便于可视化
                    team._x_ = node._x_ + radius * Math.cos(team._a_) + 600;
                    team._y_ = node._y_ + radius * Math.sin(team._a_) + 400;
                    team._p_ = node._a_;
                    calcNodePosWithMinSpacing(team, node, level + 1, minSpacing);
                });
                return;
            }

            // 非根节点：继承父节点角度
            node._p_ = parentNode._a_;

            // 层级-子节点键映射
            const childKeyMap = { 1: "project", 2: "instances", 3: "dblst", 4: "objects" };
            const childKey = childKeyMap[level];
            const children = childKey && node[childKey] !== null ? node[childKey] : [];
            const childCount = children.length;

            // 计算子节点坐标（半径=间距×层级，保障最小间距）
            const radius = minSpacing * level;
            children.forEach((child, idx) => {
                child._a_ = (2 * Math.PI / childCount) * idx;
                child._x_ = node._x_ + radius * Math.cos(child._a_);
                child._y_ = node._y_ + radius * Math.sin(child._a_);
                calcNodePosWithMinSpacing(child, node, level + 1, minSpacing);
            });
        }

        // 2. Canvas渲染函数
        function renderTree(treeData, canvas) {
            const ctx = canvas.getContext('2d');
            const tooltip = document.getElementById('tooltip');
            let hoveredNode = null;

            // 递归绘制节点与连线
            function drawNode(node, parentNode) {
                if (!node) return;

                // 绘制连线（子节点→父节点）
                if (parentNode) {
                    ctx.beginPath();
                    ctx.strokeStyle = '#ccc';
                    ctx.lineWidth = 1;
                    ctx.moveTo(node._x_, node._y_);
                    ctx.lineTo(parentNode._x_, parentNode._y_);
                    ctx.stroke();
                }

                // 绘制节点（圆形）
                ctx.beginPath();
                ctx.fillStyle = hoveredNode === node ? '#4285f4' : '#34a853';
                ctx.arc(node._x_, node._y_, 15, 0, 2 * Math.PI);
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();

                // 绘制节点名称（_n_属性）
                ctx.font = '12px Arial';
                ctx.fillStyle = '#fff';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const nodeName = node._n_ || '未命名';
                ctx.fillText(nodeName, node._x_, node._y_);

                // 递归绘制子节点
                const childKeyMap = { 1: "project", 2: "instances", 3: "dblst", 4: "objects" };
                const level = getNodeLevel(node);
                const childKey = childKeyMap[level];
                const children = childKey && node[childKey] !== null ? node[childKey] : [];
                children.forEach(child => drawNode(child, node));
            }

            // 辅助：获取节点层级
            function getNodeLevel(node) {
                let level = 0;
                let parent = node._p_;
                while (parent !== null && parent !== undefined) {
                    level++;
                    parent = node.parent?._p_;
                    node = node.parent;
                }
                return level;
            }

            // 监听鼠标hover：显示节点信息
            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                hoveredNode = null;

                // 递归判断鼠标是否在节点上
                function checkHover(node) {
                    if (!node) return;
                    const dx = mouseX - node._x_;
                    const dy = mouseY - node._y_;
                    if (dx * dx + dy * dy <= 15 * 15) { // 节点半径15
                        hoveredNode = node;
                        return true;
                    }
                    const childKeyMap = { 1: "project", 2: "instances", 3: "dblst", 4: "objects" };
                    const level = getNodeLevel(node);
                    const childKey = childKeyMap[level];
                    const children = childKey && node[childKey] !== null ? node[childKey] : [];
                    return children.some(checkHover);
                }

                checkHover(treeData);
                if (hoveredNode) {
                    // 显示tooltip：包含_a_（角度，转角度制）、_x_、_y_（原始坐标，减去画布偏移）
                    const angle = hoveredNode._a_ !== null ? (hoveredNode._a_ * 180 / Math.PI).toFixed(1) + '°' : '无';
                    const originX = (hoveredNode._x_ - 600).toFixed(1); // 还原为中心0,0的原始X
                    const originY = (hoveredNode._y_ - 400).toFixed(1); // 还原为中心0,0的原始Y
                    tooltip.innerHTML = `
                        名称：${hoveredNode._n_ || '未命名'}<br>
                        角度(_a_)：${angle}<br>
                        原始X(_x_)：${originX}<br>
                        原始Y(_y_)：${originY}
                    `;
                    tooltip.style.display = 'block';
                    tooltip.style.left = (e.clientX + 10) + 'px';
                    tooltip.style.top = (e.clientY + 10) + 'px';
                } else {
                    tooltip.style.display = 'none';
                }
                // 重新渲染（更新hover节点颜色）
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawNode(treeData, null);
            });

            // 初始渲染
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawNode(treeData, null);
        }

        // 3. 初始化：加载数据→计算坐标→渲染
        window.onload = function() {
            // 你的原始树形数据
            const treeData = {
                "_n_": "根节点",
                "teams": [
                    {"_n_":"team1","project":null,"_a_":null,"_p_":null,"_c_":null,"_x_":null,"_y_":null},
                    {"_n_":"team2","project":[
                        {"_n_":"pjt03","instances":null,"_a_":null,"_p_":null,"_c_":null,"_x_":null,"_y_":null},
                        {"_n_":"pjt05","instances":[
                            {"_n_":"ist03","dblst":[
                                {"_n_":"db3","objects":null,"_a_":null,"_p_":null,"_c_":null,"_x_":null,"_y_":null}
                            ],"_a_":null,"_p_":null,"_c_":null,"_x_":null,"_y_":null},
                            {"_n_":"ist05","dblst":[
                                {"_n_":"db3","objects":null,"_a_":null,"_p_":null,"_c_":null,"_x_":null,"_y_":null}
                            ],"_a_":null,"_p_":null,"_c_":null,"_x_":null,"_y_":null},
                            {"_n_":"ist07","dblst":[
                                {"_n_":"db3","objects":null,"_a_":null,"_p_":null,"_c_":null,"_x_":null,"_y_":null}
                            ],"_a_":null,"_p_":null,"_c_":null,"_x_":null,"_y_":null}
                        ],"_a_":null,"_p_":null,"_c_":null,"_x_":null,"_y_":null},
                        {"_n_":"pjt07","instances":[
                            {"_n_":"ist01","dblst":null,"_a_":null,"_p_":null,"_c_":null,"_x_":null,"_y_":null}
                        ],"_a_":null,"_p_":null,"_c_":null,"_x_":null,"_y_":null}
                    ],"_a_":null,"_p_":null,"_c_":null,"_x_":null,"_y_":null},
                    {"_n_":"team3","project":[
                        {"_n_":"pjt03","instances":null,"_a_":null,"_p_":null,"_c_":null,"_x_":null,"_y_":null}
                    ],"_a_":null,"_p_":null,"_c_":null,"_x_":null,"_y_":null}
                ],
                "_a_":null,"_p_":null,"_c_":null,"_x_":null,"_y_":null
            };

            // 计算节点坐标
            calcNodePosWithMinSpacing(treeData);
            // 渲染树形图
            const canvas = document.getElementById('treeCanvas');
            renderTree(treeData, canvas);
        };
    </script>
</body>
</html>
